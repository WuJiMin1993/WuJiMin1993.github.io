<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块 - 双人对战</title>
    <style>
        /* 全局样式 */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        /* 头部信息栏 */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }
        
        .room-id {
            font-size: 1.5rem;
            color: #FFD700;
        }
        
        .player-status {
            display: flex;
            gap: 20px;
        }
        
        .status-box {
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9rem;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid #4e54c8;
        }
        
        .status-box.active {
            background-color: rgba(78, 84, 200, 0.3);
            border-color: #8f94fb;
        }
        
        .status-box.inactive {
            opacity: 0.5;
        }
        
        .game-state {
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9rem;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid #4CAF50;
            margin-left: 20px;
        }
        
        /* 游戏主容器 */
        .game-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* 玩家游戏区域 */
        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .player-title {
            font-size: 1.2rem;
            color: #FFD700;
        }
        
        /* 游戏画布区域 */
        .game-area {
            position: relative;
        }
        
        /* 游戏画布 */
        .tetris-canvas {
            background-color: rgba(0, 0, 0, 0.7);
            border: 3px solid #4e54c8;
            border-radius: 5px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        /* 信息面板 */
        .info-panel {
            background-color: rgba(0, 0, 0, 0.7);
            border: 3px solid #8f94fb;
            border-radius: 5px;
            padding: 15px;
            width: 200px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        /* 分数显示 */
        .score-display {
            font-size: 1.2rem;
            margin-bottom: 15px;
            text-align: center;
            color: #4e54c8;
        }
        
        /* 下一个方块预览 */
        .next-piece-container {
            margin: 15px 0;
            text-align: center;
        }
        
        .next-piece-title {
            font-size: 1rem;
            margin-bottom: 8px;
        }
        
        .next-piece-canvas {
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #8f94fb;
            border-radius: 5px;
            margin: 0 auto;
        }
        
        /* 控制按钮区域 */
        .control-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            align-items: center;
        }
        
        .control-btn {
            padding: 10px 15px;
            font-size: 1rem;
            color: white;
            background: linear-gradient(45deg, #4e54c8, #8f94fb);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .control-btn:hover {
            background: linear-gradient(45deg, #8f94fb, #4e54c8);
            transform: translateY(-2px);
        }
        
        .control-btn:active {
            transform: translateY(1px);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 游戏结束遮罩 */
        .game-over-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .final-score {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #ff6b6b;
            text-align: center;
        }
        
        /* 返回按钮 */
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 8px 15px;
            font-size: 1rem;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #8f94fb;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background: rgba(78, 84, 200, 0.5);
        }
    </style>
</head>
<body>
    <!-- 返回按钮 -->
    <button class="back-btn" onclick="goBack()">返回主界面</button>
    
    <!-- 头部信息栏 -->
    <div class="header">
        <div class="room-id">房间号: <span id="room-id-display">000000</span></div>
        <div class="player-status">
            <div id="player1-status" class="status-box active">玩家1已加入</div>
            <div id="player2-status" class="status-box inactive">等待玩家2</div>
            <div id="game-state" class="game-state">等待玩家1开始游戏</div>
        </div>
    </div>
    
    <!-- 游戏主容器 -->
    <div class="game-container">
        <!-- 玩家1区域 -->
        <div class="player-area">
            <div class="player-title">玩家1</div>
            <div class="game-area">
                <canvas id="player1-canvas" class="tetris-canvas" width="300" height="600"></canvas>
                <div id="player1-game-over" class="game-over-mask">
                    <div id="player1-final-score" class="final-score">最终得分: 0</div>
                </div>
            </div>
            <div class="info-panel">
                <div id="player1-score" class="score-display">得分: 0</div>
                <div class="next-piece-container">
                    <div class="next-piece-title">下一个方块:</div>
                    <canvas id="player1-next-piece" class="next-piece-canvas" width="100" height="100"></canvas>
                </div>
                <div class="control-area">
                    <button id="start-btn" class="control-btn">游戏开始</button>
                </div>
            </div>
        </div>
        
        <!-- 玩家2区域 -->
        <div class="player-area">
            <div class="player-title">玩家2</div>
            <div class="game-area">
                <canvas id="player2-canvas" class="tetris-canvas" width="300" height="600"></canvas>
                <div id="player2-game-over" class="game-over-mask">
                    <div id="player2-final-score" class="final-score">最终得分: 0</div>
                </div>
            </div>
            <div class="info-panel">
                <div id="player2-score" class="score-display">得分: 0</div>
                <div class="next-piece-container">
                    <div class="next-piece-title">下一个方块:</div>
                    <canvas id="player2-next-piece" class="next-piece-canvas" width="100" height="100"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    
    <script>
        // Firebase配置
        const firebaseConfig = {       
            apiKey: "AIzaSyDHRYTBU74r31MPYVAAnRMwKM76c_-BduQ",
            authDomain: "tetrisonline-ca400.firebaseapp.com",
            projectId: "tetrisonline-ca400",
            storageBucket: "tetrisonline-ca400.appspot.com",
            messagingSenderId: "58207939196",
            appId: "1:58207939196:web:b34f403204096084ee37f9",
            measurementId: "G-GG7GNEQ718"
        };
        
        // 初始化Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // 游戏常量定义
        const COLS = 10;  // 游戏区域列数
        const ROWS = 20;  // 游戏区域行数
        const BLOCK_SIZE = 30;  // 每个方块的大小(像素)
        const NEXT_BLOCK_SIZE = 20;  // 下一个方块预览的大小
        
        // 方块形状定义
        const SHAPES = [
            [],  // 空形状(占位)
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],  // I
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],  // J
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],  // L
            [[4, 4], [4, 4]],  // O
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],  // S
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],  // T
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]   // Z
        ];
        
        // 方块颜色定义
        const COLORS = [
            '#000000',  // 0: 空
            '#00FFFF',  // 1: I (青色)
            '#0000FF',  // 2: J (蓝色)
            '#FF7F00',  // 3: L (橙色)
            '#FFFF00',  // 4: O (黄色)
            '#00FF00',  // 5: S (绿色)
            '#800080',  // 6: T (紫色)
            '#FF0000'   // 7: Z (红色)
        ];
        
        // 游戏状态变量
        let roomId = '';  // 房间ID
        let playerRole = '';  // 玩家角色(player1或player2)
        let gameStarted = false;  // 游戏是否开始
        let gameOver = false;  // 游戏是否结束
        let dropInterval = 1000;  // 方块下落间隔(毫秒)
        let dropStart;  // 上次下落时间
        let animationId;  // 动画ID(用于取消动画)
        
        // 玩家1游戏状态
        let player1Board = [];  // 玩家1游戏板
        let player1Piece = null;  // 玩家1当前方块
        let player1NextPiece = null;  // 玩家1下一个方块
        let player1Score = 0;  // 玩家1分数
        
        // 玩家2游戏状态
        let player2Board = [];  // 玩家2游戏板
        let player2Piece = null;  // 玩家2当前方块
        let player2NextPiece = null;  // 玩家2下一个方块
        let player2Score = 0;  // 玩家2分数
        
        // DOM元素
        let player1Canvas, player1Ctx;  // 玩家1画布和上下文
        let player2Canvas, player2Ctx;  // 玩家2画布和上下文
        let player1NextCanvas, player1NextCtx;  // 玩家1下一个方块画布
        let player2NextCanvas, player2NextCtx;  // 玩家2下一个方块画布
        
        // Firebase引用
        let roomRef;  // 房间引用
        let gameStateRef;  // 游戏状态引用
        let player1Ref;  // 玩家1数据引用
        let player2Ref;  // 玩家2数据引用
        
        // 初始化游戏
        function init() {
            console.log('初始化双人游戏...');
            
            // 获取玩家角色和房间ID
            playerRole = localStorage.getItem('playerRole');
            roomId = localStorage.getItem('roomId');
            
            if (!playerRole || !roomId) {
                console.error('无法获取玩家角色或房间ID');
                alert('游戏初始化失败，请返回主界面重新加入房间');
                return;
            }
            
            console.log(`玩家角色: ${playerRole}, 房间ID: ${roomId}`);
            
            // 设置房间号显示
            document.getElementById('room-id-display').textContent = roomId;
            
            // 获取画布和上下文
            player1Canvas = document.getElementById('player1-canvas');
            player1Ctx = player1Canvas.getContext('2d');
            player2Canvas = document.getElementById('player2-canvas');
            player2Ctx = player2Canvas.getContext('2d');
            player1NextCanvas = document.getElementById('player1-next-piece');
            player1NextCtx = player1NextCanvas.getContext('2d');
            player2NextCanvas = document.getElementById('player2-next-piece');
            player2NextCtx = player2NextCanvas.getContext('2d');
            
            // 初始化游戏板
            initBoards();
            
            // 设置Firebase引用
            setupFirebaseRefs();
            
            // 设置事件监听器
            setupEventListeners();
            
            // 如果是玩家1，生成第一个下一个方块
            if (playerRole === 'player1') {
                console.log('玩家1生成初始方块...');
                player1NextPiece = generatePiece();
                updatePlayer1NextPiece();
            }
            
            // 绘制初始状态
            drawPlayer1Board();
            drawPlayer2Board();
        }
        
        // 初始化游戏板
        function initBoards() {
            console.log('初始化游戏板...');
            
            // 初始化玩家1游戏板
            for (let r = 0; r < ROWS; r++) {
                player1Board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    player1Board[r][c] = 0;
                }
            }
            
            // 初始化玩家2游戏板
            for (let r = 0; r < ROWS; r++) {
                player2Board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    player2Board[r][c] = 0;
                }
            }
        }
        
        // 设置Firebase引用
        function setupFirebaseRefs() {
            console.log('设置Firebase引用...');
            
            roomRef = database.ref('rooms/' + roomId);
            gameStateRef = database.ref('rooms/' + roomId + '/gameState');
            player1Ref = database.ref('rooms/' + roomId + '/player1');
            player2Ref = database.ref('rooms/' + roomId + '/player2');
            
            // 监听玩家2加入状态
            player2Ref.on('value', (snapshot) => {
                const player2Data = snapshot.val();
                if (player2Data && player2Data.joined) {
                    console.log('玩家2已加入');
                    document.getElementById('player2-status').textContent = '玩家2已加入';
                    document.getElementById('player2-status').classList.add('active');
                    document.getElementById('player2-status').classList.remove('inactive');
                    
                    // 如果是玩家2，生成第一个下一个方块
                    if (playerRole === 'player2') {
                        player2NextPiece = generatePiece();
                        updatePlayer2NextPiece();
                    }
                } else {
                    console.log('等待玩家2加入...');
                    document.getElementById('player2-status').textContent = '等待玩家2';
                    document.getElementById('player2-status').classList.remove('active');
                    document.getElementById('player2-status').classList.add('inactive');
                }
            });
            
            // 监听游戏状态变化
            gameStateRef.on('value', (snapshot) => {
                const state = snapshot.val();
                if (state) {
                    console.log('游戏状态更新:', state);
                    updateGameStateUI(state);
                    
                    // 如果游戏开始且当前是玩家2，开始游戏
                    if (state === 'playing' && playerRole === 'player2' && !gameStarted) {
                        startGame();
                    }
                }
            });
            
            // 监听玩家1游戏数据
            player1Ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    if (data.board) {
                        player1Board = data.board;
                    }
                    if (data.currentPiece) {
                        player1Piece = data.currentPiece;
                    }
                    if (data.nextPiece) {
                        player1NextPiece = data.nextPiece;
                    }
                    if (data.score !== undefined) {
                        player1Score = data.score;
                        document.getElementById('player1-score').textContent = `得分: ${player1Score}`;
                    }
                    if (data.gameOver) {
                        showGameOver('player1');
                    }
                    
                    drawPlayer1Board();
                    updatePlayer1NextPiece();
                }
            });
            
            // 监听玩家2游戏数据
            player2Ref.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    if (data.board) {
                        player2Board = data.board;
                    }
                    if (data.currentPiece) {
                        player2Piece = data.currentPiece;
                    }
                    if (data.nextPiece) {
                        player2NextPiece = data.nextPiece;
                    }
                    if (data.score !== undefined) {
                        player2Score = data.score;
                        document.getElementById('player2-score').textContent = `得分: ${player2Score}`;
                    }
                    if (data.gameOver) {
                        showGameOver('player2');
                    }
                    
                    drawPlayer2Board();
                    updatePlayer2NextPiece();
                }
            });
            
            // 设置玩家加入状态
            if (playerRole === 'player1') {
                player1Ref.update({
                    joined: true
                });
            } else if (playerRole === 'player2') {
                player2Ref.update({
                    joined: true
                });
            }
        }
        
        // 更新游戏状态UI
        function updateGameStateUI(state) {
            const gameStateElement = document.getElementById('game-state');
            
            switch (state) {
                case 'waiting':
                    gameStateElement.textContent = '等待玩家1开始游戏';
                    break;
                case 'playing':
                    gameStateElement.textContent = '游戏进行中';
                    break;
                case 'ended':
                    gameStateElement.textContent = '游戏结束';
                    break;
                default:
                    gameStateElement.textContent = '等待玩家1开始游戏';
            }
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            console.log('设置事件监听器...');
            
            // 键盘控制
            document.addEventListener('keydown', function(e) {
                if (!gameStarted || gameOver) return;
                
                // 根据玩家角色处理不同按键
                if (playerRole === 'player1') {
                    handlePlayer1KeyPress(e);
                } else if (playerRole === 'player2') {
                    handlePlayer2KeyPress(e);
                }
            });
            
            // 开始按钮
            document.getElementById('start-btn').addEventListener('click', function() {
                if (playerRole === 'player1' && !gameStarted) {
                    gameStateRef.set('playing');
                    startGame();
                }
            });
        }
        
        // 处理玩家1按键
        function handlePlayer1KeyPress(e) {
            switch (e.keyCode) {
                case 37: // 左箭头
                    movePlayer1Left();
                    break;
                case 39: // 右箭头
                    movePlayer1Right();
                    break;
                case 40: // 下箭头
                    movePlayer1Down();
                    break;
                case 38: // 上箭头
                    rotatePlayer1();
                    break;
                case 32: // 空格
                    hardDropPlayer1();
                    break;
            }
        }
        
        // 处理玩家2按键
        function handlePlayer2KeyPress(e) {
            switch (e.keyCode) {
                case 65: // A键 (左)
                    movePlayer2Left();
                    break;
                case 68: // D键 (右)
                    movePlayer2Right();
                    break;
                case 83: // S键 (下)
                    movePlayer2Down();
                    break;
                case 87: // W键 (上)
                    rotatePlayer2();
                    break;
                case 16: // Shift键 (急速下落)
                    hardDropPlayer2();
                    break;
            }
        }
        
        // 生成随机方块
        function generatePiece() {
            // 随机选择方块类型(1-7)
            const type = Math.floor(Math.random() * 7) + 1;
            const shape = SHAPES[type];
            
            // 计算方块初始位置(居中)
            const col = Math.floor((COLS - shape[0].length) / 2);
            const row = 0;
            
            return { type, shape, row, col };
        }
        
        // 绘制玩家1游戏板
        function drawPlayer1Board() {
            // 清除画布
            player1Ctx.clearRect(0, 0, player1Canvas.width, player1Canvas.height);
            
            // 绘制游戏板
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (player1Board[r][c]) {
                        drawBlock(player1Ctx, c, r, player1Board[r][c]);
                    }
                }
            }
            
            // 绘制当前方块
            if (player1Piece) {
                drawPiece(player1Ctx, player1Piece);
            }
            
            // 绘制网格线
            drawGrid(player1Ctx, player1Canvas);
        }
        
        // 绘制玩家2游戏板
        function drawPlayer2Board() {
            // 清除画布
            player2Ctx.clearRect(0, 0, player2Canvas.width, player2Canvas.height);
            
            // 绘制游戏板
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (player2Board[r][c]) {
                        drawBlock(player2Ctx, c, r, player2Board[r][c]);
                    }
                }
            }
            
            // 绘制当前方块
            if (player2Piece) {
                drawPiece(player2Ctx, player2Piece);
            }
            
            // 绘制网格线
            drawGrid(player2Ctx, player2Canvas);
        }
        
        // 绘制单个方块
        function drawBlock(ctx, col, row, type) {
            const x = col * BLOCK_SIZE;
            const y = row * BLOCK_SIZE;
            
            // 绘制方块主体
            ctx.fillStyle = COLORS[type];
            ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 绘制方块边框
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 添加高光效果
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(x + 2, y + 2, BLOCK_SIZE - 4, 4);
            ctx.fillRect(x + 2, y + 2, 4, BLOCK_SIZE - 4);
        }
        
        // 绘制网格线
        function drawGrid(ctx, canvas) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 绘制垂直线
            for (let c = 0; c <= COLS; c++) {
                ctx.beginPath();
                ctx.moveTo(c * BLOCK_SIZE, 0);
                ctx.lineTo(c * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // 绘制水平线
            for (let r = 0; r <= ROWS; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * BLOCK_SIZE);
                ctx.lineTo(COLS * BLOCK_SIZE, r * BLOCK_SIZE);
                ctx.stroke();
            }
        }
        
        // 绘制方块
        function drawPiece(ctx, piece) {
            const { shape, row, col } = piece;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        drawBlock(ctx, col + c, row + r, shape[r][c]);
                    }
                }
            }
        }
        
        // 更新玩家1下一个方块显示
        function updatePlayer1NextPiece() {
            if (!player1NextPiece) return;
            
            // 清除下一个方块画布
            player1NextCtx.clearRect(0, 0, player1NextCanvas.width, player1NextCanvas.height);
            
            const { shape } = player1NextPiece;
            const centerX = (player1NextCanvas.width - shape[0].length * NEXT_BLOCK_SIZE) / 2;
            const centerY = (player1NextCanvas.height - shape.length * NEXT_BLOCK_SIZE) / 2;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const x = centerX + c * NEXT_BLOCK_SIZE;
                        const y = centerY + r * NEXT_BLOCK_SIZE;
                        
                        // 绘制方块主体
                        player1NextCtx.fillStyle = COLORS[shape[r][c]];
                        player1NextCtx.fillRect(x, y, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                        
                        // 绘制方块边框
                        player1NextCtx.strokeStyle = '#000';
                        player1NextCtx.lineWidth = 1;
                        player1NextCtx.strokeRect(x, y, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                    }
                }
            }
        }
        
        // 更新玩家2下一个方块显示
        function updatePlayer2NextPiece() {
            if (!player2NextPiece) return;
            
            // 清除下一个方块画布
            player2NextCtx.clearRect(0, 0, player2NextCanvas.width, player2NextCanvas.height);
            
            const { shape } = player2NextPiece;
            const centerX = (player2NextCanvas.width - shape[0].length * NEXT_BLOCK_SIZE) / 2;
            const centerY = (player2NextCanvas.height - shape.length * NEXT_BLOCK_SIZE) / 2;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const x = centerX + c * NEXT_BLOCK_SIZE;
                        const y = centerY + r * NEXT_BLOCK_SIZE;
                        
                        // 绘制方块主体
                        player2NextCtx.fillStyle = COLORS[shape[r][c]];
                        player2NextCtx.fillRect(x, y, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                        
                        // 绘制方块边框
                        player2NextCtx.strokeStyle = '#000';
                        player2NextCtx.lineWidth = 1;
                        player2NextCtx.strokeRect(x, y, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                    }
                }
            }
        }
        
        // 开始游戏
        function startGame() {
            console.log('游戏开始...');
            
            gameStarted = true;
            gameOver = false;
            document.getElementById('start-btn').disabled = true;
            
            // 如果是玩家1，设置初始方块
            if (playerRole === 'player1') {
                player1Piece = player1NextPiece;
                player1NextPiece = generatePiece();
                updatePlayer1Data();
            }
            
            // 如果是玩家2，设置初始方块
            if (playerRole === 'player2') {
                player2Piece = player2NextPiece;
                player2NextPiece = generatePiece();
                updatePlayer2Data();
            }
            
            // 开始游戏循环
            dropStart = null;
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 游戏主循环
        function gameLoop(timestamp) {
            if (gameOver) {
                return;
            }
            
            if (!gameStarted) {
                animationId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // 控制方块下落速度
            if (!dropStart) {
                dropStart = timestamp;
            }
            
            const delta = timestamp - dropStart;
            
            if (delta > dropInterval) {
                if (playerRole === 'player1') {
                    movePlayer1Down();
                } else if (playerRole === 'player2') {
                    movePlayer2Down();
                }
                dropStart = timestamp;
            }
            
            // 根据玩家角色绘制对应的游戏板
            if (playerRole === 'player1') {
                drawPlayer1Board();
            } else {
                drawPlayer2Board();
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 玩家1左移
        function movePlayer1Left() {
            if (!player1Piece || gameOver) return;
            
            if (!collision(player1Board, player1Piece, -1, 0)) {
                player1Piece.col--;
                updatePlayer1Data();
            }
        }
        
        // 玩家1右移
        function movePlayer1Right() {
            if (!player1Piece || gameOver) return;
            
            if (!collision(player1Board, player1Piece, 1, 0)) {
                player1Piece.col++;
                updatePlayer1Data();
            }
        }
        
        // 玩家1下落
        function movePlayer1Down() {
            if (!player1Piece || gameOver) return;
            
            if (!collision(player1Board, player1Piece, 0, 1)) {
                player1Piece.row++;
                updatePlayer1Data();
                return true;
            }
            
            // 如果不能移动，则固定方块
            lockPlayer1Piece();
            
            // 检查是否有完整的行
            checkPlayer1Rows();
            
            // 生成新方块
            player1Piece = player1NextPiece;
            player1NextPiece = generatePiece();
            updatePlayer1Data();
            
            // 检查游戏是否结束
            if (collision(player1Board, player1Piece, 0, 0)) {
                player1GameOver();
            }
            
            return false;
        }
        
        // 玩家1快速下落
        function hardDropPlayer1() {
            if (!player1Piece || gameOver) return;
            
            while (movePlayer1Down()) {
                // 继续下落直到不能移动
            }
        }
        
        // 玩家1旋转
        function rotatePlayer1() {
            if (!player1Piece || gameOver) return;
            
            const newShape = rotateMatrix(player1Piece.shape);
            
            if (!collision(player1Board, { ...player1Piece, shape: newShape }, 0, 0)) {
                player1Piece.shape = newShape;
                updatePlayer1Data();
            }
        }
        
        // 玩家2左移
        function movePlayer2Left() {
            if (!player2Piece || gameOver) return;
            
            if (!collision(player2Board, player2Piece, -1, 0)) {
                player2Piece.col--;
                updatePlayer2Data();
            }
        }
        
        // 玩家2右移
        function movePlayer2Right() {
            if (!player2Piece || gameOver) return;
            
            if (!collision(player2Board, player2Piece, 1, 0)) {
                player2Piece.col++;
                updatePlayer2Data();
            }
        }
        
        // 玩家2下落
        function movePlayer2Down() {
            if (!player2Piece || gameOver) return;
            
            if (!collision(player2Board, player2Piece, 0, 1)) {
                player2Piece.row++;
                updatePlayer2Data();
                return true;
            }
            
            // 如果不能移动，则固定方块
            lockPlayer2Piece();
            
            // 检查是否有完整的行
            checkPlayer2Rows();
            
            // 生成新方块
            player2Piece = player2NextPiece;
            player2NextPiece = generatePiece();
            updatePlayer2Data();
            
            // 检查游戏是否结束
            if (collision(player2Board, player2Piece, 0, 0)) {
                player2GameOver();
            }
            
            return false;
        }
        
        // 玩家2快速下落
        function hardDropPlayer2() {
            if (!player2Piece || gameOver) return;
            
            while (movePlayer2Down()) {
                // 继续下落直到不能移动
            }
        }
        
        // 玩家2旋转
        function rotatePlayer2() {
            if (!player2Piece || gameOver) return;
            
            const newShape = rotateMatrix(player2Piece.shape);
            
            if (!collision(player2Board, { ...player2Piece, shape: newShape }, 0, 0)) {
                player2Piece.shape = newShape;
                updatePlayer2Data();
            }
        }
        
        // 旋转矩阵(顺时针90度)
        function rotateMatrix(matrix) {
            const N = matrix.length;
            const rotated = [];
            
            for (let i = 0; i < N; i++) {
                rotated[i] = [];
                for (let j = 0; j < N; j++) {
                    rotated[i][j] = matrix[N - j - 1][i];
                }
            }
            
            return rotated;
        }
        
        // 碰撞检测
        function collision(board, piece, offsetX, offsetY) {
            const { row, col, shape } = piece;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (!shape[r][c]) continue;
                    
                    const newX = col + c + offsetX;
                    const newY = row + r + offsetY;
                    
                    // 检查边界
                    if (newX < 0 || newX >= COLS || newY >= ROWS) {
                        return true;
                    }
                    
                    // 检查是否与其他方块重叠
                    if (newY >= 0 && board[newY][newX]) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 固定玩家1方块到游戏板
        function lockPlayer1Piece() {
            const { shape, row, col } = player1Piece;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const boardRow = row + r;
                        const boardCol = col + c;
                        
                        if (boardRow >= 0) {
                            player1Board[boardRow][boardCol] = shape[r][c];
                        }
                    }
                }
            }
            
            updatePlayer1Data();
        }
        
        // 固定玩家2方块到游戏板
        function lockPlayer2Piece() {
            const { shape, row, col } = player2Piece;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const boardRow = row + r;
                        const boardCol = col + c;
                        
                        if (boardRow >= 0) {
                            player2Board[boardRow][boardCol] = shape[r][c];
                        }
                    }
                }
            }
            
            updatePlayer2Data();
        }
        
        // 检查玩家1是否有完整的行
        function checkPlayer1Rows() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                if (player1Board[r].every(cell => cell !== 0)) {
                    // 移除该行
                    player1Board.splice(r, 1);
                    // 在顶部添加新行
                    player1Board.unshift(Array(COLS).fill(0));
                    // 因为删除了行，需要再次检查同一行(现在是新行)
                    r++;
                    linesCleared++;
                }
            }
            
            if (linesCleared > 0) {
                // 更新分数
                updatePlayer1Score(linesCleared);
            }
            
            updatePlayer1Data();
        }
        
        // 检查玩家2是否有完整的行
        function checkPlayer2Rows() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                if (player2Board[r].every(cell => cell !== 0)) {
                    // 移除该行
                    player2Board.splice(r, 1);
                    // 在顶部添加新行
                    player2Board.unshift(Array(COLS).fill(0));
                    // 因为删除了行，需要再次检查同一行(现在是新行)
                    r++;
                    linesCleared++;
                }
            }
            
            if (linesCleared > 0) {
                // 更新分数
                updatePlayer2Score(linesCleared);
            }
            
            updatePlayer2Data();
        }
        
        // 更新玩家1分数
        function updatePlayer1Score(lines) {
            // 根据消除的行数计算得分
            const points = [0, 40, 100, 300, 1200][lines];
            player1Score += points;
            
            // 更新分数显示
            document.getElementById('player1-score').textContent = `得分: ${player1Score}`;
            
            // 根据分数调整下落速度
            adjustPlayer1Speed();
        }
        
        // 更新玩家2分数
        function updatePlayer2Score(lines) {
            // 根据消除的行数计算得分
            const points = [0, 40, 100, 300, 1200][lines];
            player2Score += points;
            
            // 更新分数显示
            document.getElementById('player2-score').textContent = `得分: ${player2Score}`;
            
            // 根据分数调整下落速度
            adjustPlayer2Speed();
        }
        
        // 根据玩家1分数调整下落速度
        function adjustPlayer1Speed() {
            // 每1000分加快速度
            const level = Math.floor(player1Score / 1000);
            // 速度上限为100ms
            dropInterval = Math.max(100, 1000 - level * 100);
        }
        
        // 根据玩家2分数调整下落速度
        function adjustPlayer2Speed() {
            // 每1000分加快速度
            const level = Math.floor(player2Score / 1000);
            // 速度上限为100ms
            dropInterval = Math.max(100, 1000 - level * 100);
        }
        
        // 玩家1游戏结束
        function player1GameOver() {
            console.log('玩家1游戏结束');
            gameOver = true;
            gameStateRef.set('ended');
            showGameOver('player1');
            updatePlayer1Data();
        }
        
        // 玩家2游戏结束
        function player2GameOver() {
            console.log('玩家2游戏结束');
            gameOver = true;
            gameStateRef.set('ended');
            showGameOver('player2');
            updatePlayer2Data();
        }
        
        // 显示游戏结束
        function showGameOver(player) {
            const maskId = `${player}-game-over`;
            const scoreId = `${player}-final-score`;
            const score = player === 'player1' ? player1Score : player2Score;
            
            document.getElementById(scoreId).textContent = `最终得分: ${score}`;
            document.getElementById(maskId).style.display = 'flex';
        }
        
        // 更新玩家1数据到Firebase
        function updatePlayer1Data() {
            if (playerRole !== 'player1') return;
            
            player1Ref.update({
                board: player1Board,
                currentPiece: player1Piece,
                nextPiece: player1NextPiece,
                score: player1Score,
                gameOver: gameOver
            });
        }
        
        // 更新玩家2数据到Firebase
        function updatePlayer2Data() {
            if (playerRole !== 'player2') return;
            
            player2Ref.update({
                board: player2Board,
                currentPiece: player2Piece,
                nextPiece: player2NextPiece,
                score: player2Score,
                gameOver: gameOver
            });
        }
        
        // 返回主界面
        function goBack() {
            // 清理Firebase数据
            if (playerRole === 'player1') {
                roomRef.remove();
            }
            
            window.location.href = 'index.html';
        }
        
        // 初始化游戏
        window.addEventListener('load', init);
    </script>
</body>
</html>
