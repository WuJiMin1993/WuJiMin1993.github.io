<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块 - 单人游戏</title>
    <style>
        /* 全局样式重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #121212;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
        }
        
        /* 游戏主容器 */
        #game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 30px;
            width: 100%;
            max-width: 900px;
        }
        
        /* 游戏区域 */
        #tetris-board {
            border: 3px solid #00ffff;
            background-color: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        /* 信息面板 */
        .info-panel {
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 20px;
            width: 220px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        /* 下一个方块预览 */
        #next-piece-container {
            margin-bottom: 25px;
            text-align: center;
        }
        
        #next-piece {
            border: 2px solid #00ffff;
            background-color: rgba(0, 0, 0, 0.5);
            margin-top: 10px;
        }
        
        /* 分数显示 */
        #score-display {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #00ffff;
            text-align: center;
        }
        
        /* 游戏控制按钮 */
        .control-button {
            padding: 12px 20px;
            margin: 8px 0;
            width: 100%;
            background: linear-gradient(145deg, #0066ff, #00ccff);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .control-button:hover {
            background: linear-gradient(145deg, #00ccff, #0066ff);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* 返回按钮 */
        #back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            color: #00ffff;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        #back-button:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* 游戏说明 */
        #instructions {
            margin-top: 30px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 8px;
            max-width: 900px;
            width: 90%;
            line-height: 1.6;
        }
        
        #instructions h3 {
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.5rem;
        }
        
        #instructions p {
            margin-bottom: 10px;
        }
        
        /* 游戏结束弹窗 */
        #game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal-content {
            background-color: rgba(0, 0, 0, 0.9);
            border: 3px solid #00ffff;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #ff5555;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.7);
        }
        
        .final-score {
            font-size: 2rem;
            margin-bottom: 35px;
            color: #00ffff;
        }
        
        /* 方块颜色 */
        .cell {
            width: 25px;
            height: 25px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* 不同方块的背景色 */
        .cell.I { background-color: #00ffff; }
        .cell.O { background-color: #ffff00; }
        .cell.T { background-color: #aa00ff; }
        .cell.S { background-color: #00ff00; }
        .cell.Z { background-color: #ff0000; }
        .cell.J { background-color: #0000ff; }
        .cell.L { background-color: #ffaa00; }
        .cell.grey { background-color: #555555; }
        
        /* 标题样式 */
        .game-title {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
            margin-bottom: 20px;
            font-size: 2rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- 返回按钮 -->
    <div id="back-button" title="返回主界面">←</div>
    
    <!-- 游戏标题 -->
    <h1 class="game-title">俄罗斯方块</h1>
    
    <!-- 游戏主容器 -->
    <div id="game-container" data-interface-id="1001">
        <!-- 游戏区域 -->
        <div>
            <canvas id="tetris-board" width="300" height="600"></canvas>
        </div>
        
        <!-- 信息面板 -->
        <div class="info-panel">
            <div id="score-display">得分: 0</div>
            
            <div id="next-piece-container">
                <h3>下一个方块</h3>
                <canvas id="next-piece" width="120" height="120"></canvas>
            </div>
            
            <button id="start-button" class="control-button">开始游戏</button>
            <button id="pause-button" class="control-button" disabled>暂停</button>
        </div>
    </div>
    
    <!-- 游戏说明 -->
    <div id="instructions">
        <h3>游戏说明</h3>
        <p>← → 键: 左右移动方块</p>
        <p>↑ 键: 旋转方块</p>
        <p>↓ 键: 加速下落</p>
        <p>空格键: 直接落到底部</p>
        <p>P 键: 暂停/继续游戏</p>
    </div>
    
    <!-- 游戏结束弹窗 -->
    <div id="game-over-modal">
        <div class="modal-content">
            <div class="modal-title">游戏结束!</div>
            <div class="final-score">最终得分: <span id="final-score">0</span></div>
            <button id="restart-button" class="control-button">重新开始</button>
        </div>
    </div>

    <script>
        // 游戏常量
        const COLS = 10; // 游戏区域列数
        const ROWS = 20; // 游戏区域行数
        const BLOCK_SIZE = 30; // 每个方块的大小(像素)
        const NEXT_BLOCK_SIZE = 24; // 下一个方块预览的大小
        
        // 方块形状定义
        const SHAPES = [
            // I 形
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            // J 形
            [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // L 形
            [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // O 形
            [
                [1, 1],
                [1, 1]
            ],
            // S 形
            [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0]
            ],
            // T 形
            [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // Z 形
            [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0]
            ]
        ];
        
        // 方块颜色
        const COLORS = [
            '#00ffff', // I - 青色
            '#0000ff', // J - 蓝色
            '#ffaa00', // L - 橙色
            '#ffff00', // O - 黄色
            '#00ff00', // S - 绿色
            '#aa00ff', // T - 紫色
            '#ff0000'  // Z - 红色
        ];
        
        // 游戏状态变量
        let canvas, ctx; // 游戏画布和上下文
        let nextCanvas, nextCtx; // 下一个方块预览画布
        let board = []; // 游戏板数组
        let currentPiece = null; // 当前方块
        let nextPiece = null; // 下一个方块
        let score = 0; // 当前分数
        let gameOver = false; // 游戏是否结束
        let isPaused = false; // 游戏是否暂停
        let isStarted = false; // 游戏是否已开始
        let dropInterval = 1000; // 方块下落间隔(毫秒)
        let dropStart; // 下落开始时间
        let animationId; // 动画ID
        
        // 速度等级和对应的下落间隔
        const SPEED_LEVELS = [
            { score: 0, interval: 1000 },    // 初始速度
            { score: 1000, interval: 700 },  // 1000分后加速
            { score: 3000, interval: 500 },  // 3000分后加速
            { score: 6000, interval: 300 },  // 6000分后加速
            { score: 10000, interval: 200 }  // 10000分后加速
        ];
        
        // DOM元素
        const scoreDisplay = document.getElementById('score-display');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const backButton = document.getElementById('back-button');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        
        // 初始化游戏
        function init() {
            // 获取游戏画布和上下文
            canvas = document.getElementById('tetris-board');
            ctx = canvas.getContext('2d');
            
            // 获取下一个方块预览画布
            nextCanvas = document.getElementById('next-piece');
            nextCtx = nextCanvas.getContext('2d');
            
            // 设置画布大小
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
            
            // 初始化游戏板
            createBoard();
            
            // 生成下一个方块（但不生成当前方块，直到游戏开始）
            nextPiece = generatePiece();
            
            // 设置事件监听器
            setEventListeners();
            
            // 绘制初始状态
            draw();
            drawNextPiece();
        }
        
        // 创建游戏板
        function createBoard() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = 0;
                }
            }
        }
        
        // 生成新方块
        function generatePiece() {
            const randomIndex = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[randomIndex];
            const color = COLORS[randomIndex];
            
            return {
                shape: shape,
                color: color,
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
        }
        
        // 生成新方块并设置下一个方块
        function generateNewPiece() {
            currentPiece = nextPiece;
            nextPiece = generatePiece();
            
            // 检查游戏是否结束
            if (collision(0, 0)) {
                gameOver = true;
                showGameOver();
            }
        }
        
        // 绘制游戏板
        function draw() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格线（仅在游戏未开始时显示）
            if (!isStarted) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 0.5;
                
                // 绘制垂直线
                for (let c = 0; c <= COLS; c++) {
                    ctx.beginPath();
                    ctx.moveTo(c * BLOCK_SIZE, 0);
                    ctx.lineTo(c * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                    ctx.stroke();
                }
                
                // 绘制水平线
                for (let r = 0; r <= ROWS; r++) {
                    ctx.beginPath();
                    ctx.moveTo(0, r * BLOCK_SIZE);
                    ctx.lineTo(COLS * BLOCK_SIZE, r * BLOCK_SIZE);
                    ctx.stroke();
                }
            }
            
            // 绘制已固定的方块
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawBlock(c, r, board[r][c]);
                    }
                }
            }
            
            // 绘制当前移动的方块（如果游戏已开始）
            if (isStarted && currentPiece) {
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            drawBlock(
                                currentPiece.x + c,
                                currentPiece.y + r,
                                currentPiece.color
                            );
                        }
                    }
                }
            }
        }
        
        // 绘制单个方块
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(
                x * BLOCK_SIZE,
                y * BLOCK_SIZE,
                BLOCK_SIZE,
                BLOCK_SIZE
            );
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.strokeRect(
                x * BLOCK_SIZE,
                y * BLOCK_SIZE,
                BLOCK_SIZE,
                BLOCK_SIZE
            );
            
            // 添加高光效果
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(
                x * BLOCK_SIZE + 2,
                y * BLOCK_SIZE + 2,
                BLOCK_SIZE - 4,
                2
            );
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(
                x * BLOCK_SIZE + 2,
                y * BLOCK_SIZE + 4,
                BLOCK_SIZE - 4,
                BLOCK_SIZE - 6
            );
        }
        
        // 绘制下一个方块预览
        function drawNextPiece() {
            // 清空预览画布
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (nextPiece) {
                // 计算居中位置
                const offsetX = (nextCanvas.width - nextPiece.shape[0].length * NEXT_BLOCK_SIZE) / 2;
                const offsetY = (nextCanvas.height - nextPiece.shape.length * NEXT_BLOCK_SIZE) / 2;
                
                // 绘制下一个方块
                for (let r = 0; r < nextPiece.shape.length; r++) {
                    for (let c = 0; c < nextPiece.shape[r].length; c++) {
                        if (nextPiece.shape[r][c]) {
                            nextCtx.fillStyle = nextPiece.color;
                            nextCtx.fillRect(
                                offsetX + c * NEXT_BLOCK_SIZE,
                                offsetY + r * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE
                            );
                            
                            nextCtx.strokeStyle = '#000000';
                            nextCtx.strokeRect(
                                offsetX + c * NEXT_BLOCK_SIZE,
                                offsetY + r * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE
                            );
                        }
                    }
                }
            }
        }
        
        // 检测碰撞
        function collision(offsetX, offsetY, piece = currentPiece) {
            if (!piece) return false;
            
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    // 如果方块单元为空则跳过
                    if (!piece.shape[r][c]) continue;
                    
                    const newX = piece.x + c + offsetX;
                    const newY = piece.y + r + offsetY;
                    
                    // 检查是否超出边界
                    if (newX < 0 || newX >= COLS || newY >= ROWS) {
                        return true;
                    }
                    
                    // 检查是否与已固定的方块重叠
                    if (newY >= 0 && board[newY][newX]) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // 旋转方块
        function rotate() {
            if (!isStarted || isPaused || gameOver) return;
            
            // 创建旋转后的形状
            const rotated = [];
            for (let c = 0; c < currentPiece.shape[0].length; c++) {
                rotated[c] = [];
                for (let r = currentPiece.shape.length - 1; r >= 0; r--) {
                    rotated[c].push(currentPiece.shape[r][c]);
                }
            }
            
            // 保存原始形状以便回滚
            const originalShape = currentPiece.shape;
            currentPiece.shape = rotated;
            
            // 检查旋转后是否碰撞
            if (collision(0, 0)) {
                // 如果碰撞，尝试左右移动
                if (!collision(-1, 0)) {
                    currentPiece.x -= 1;
                } else if (!collision(1, 0)) {
                    currentPiece.x += 1;
                } else {
                    // 无法旋转，恢复原始形状
                    currentPiece.shape = originalShape;
                }
            }
            
            draw();
        }
        
        // 移动方块
        function move(offsetX, offsetY) {
            if (!isStarted || isPaused || gameOver) return false;
            
            if (!collision(offsetX, offsetY)) {
                currentPiece.x += offsetX;
                currentPiece.y += offsetY;
                draw();
                return true;
            }
            
            // 如果是向下移动且不能移动，则固定方块
            if (offsetY === 1) {
                lockPiece();
                generateNewPiece();
                draw();
                drawNextPiece();
            }
            
            return false;
        }
        
        // 快速下落
        function hardDrop() {
            if (!isStarted || isPaused || gameOver) return;
            
            while (move(0, 1)) {
                // 继续下落直到不能移动
            }
            
            // 固定方块并生成新方块
            lockPiece();
            generateNewPiece();
            draw();
            drawNextPiece();
        }
        
        // 固定方块到游戏板
        function lockPiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (!currentPiece.shape[r][c]) continue;
                    
                    // 确保不会超出上边界
                    if (currentPiece.y + r < 0) continue;
                    
                    board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                }
            }
            
            // 检查并清除已填满的行
            clearLines();
        }
        
        // 清除已填满的行
        function clearLines() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                // 检查当前行是否已填满
                const isLineFull = board[r].every(cell => cell !== 0);
                
                if (isLineFull) {
                    // 移除当前行
                    board.splice(r, 1);
                    // 在顶部添加新行
                    board.unshift(new Array(COLS).fill(0));
                    // 因为删除了行，需要重新检查当前行
                    r++;
                    linesCleared++;
                }
            }
            
            // 更新分数
            if (linesCleared > 0) {
                updateScore(linesCleared);
            }
        }
        
        // 更新分数
        function updateScore(linesCleared) {
            // 根据消除的行数计算得分
            const points = [0, 40, 100, 300, 1200]; // 0, 1, 2, 3, 4行
            score += points[linesCleared];
            
            // 更新显示
            scoreDisplay.textContent = `得分: ${score}`;
            
            // 根据分数调整下落速度
            for (let i = SPEED_LEVELS.length - 1; i >= 0; i--) {
                if (score >= SPEED_LEVELS[i].score) {
                    dropInterval = SPEED_LEVELS[i].interval;
                    break;
                }
            }
        }
        
        // 游戏主循环
        function gameLoop(timestamp) {
            if (!isStarted || gameOver || isPaused) {
                return;
            }
            
            // 计算时间差
            const delta = timestamp - dropStart;
            
            // 如果时间差大于下落间隔，方块下落
            if (delta > dropInterval) {
                if (!move(0, 1)) {
                    // 如果不能下落，固定方块并生成新方块
                    lockPiece();
                    generateNewPiece();
                    drawNextPiece();
                }
                dropStart = timestamp;
            }
            
            // 绘制游戏状态
            draw();
            
            // 继续循环
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 开始游戏
        function startGame() {
            if (gameOver) {
                resetGame();
            }
            
            // 如果是第一次开始游戏，生成当前方块
            if (!isStarted) {
                generateNewPiece();
                isStarted = true;
            }
            
            gameOver = false;
            isPaused = false;
            
            // 更新按钮状态
            startButton.textContent = '重新开始';
            pauseButton.disabled = false;
            pauseButton.textContent = '暂停';
            
            // 开始游戏循环
            dropStart = performance.now();
            animationId = requestAnimationFrame(gameLoop);
            
            // 绘制游戏状态
            draw();
            drawNextPiece();
        }
        
        // 暂停/继续游戏
        function togglePause() {
            if (!isStarted || gameOver) return;
            
            isPaused = !isPaused;
            
            if (isPaused) {
                cancelAnimationFrame(animationId);
                pauseButton.textContent = '继续';
            } else {
                dropStart = performance.now() - (dropInterval - (performance.now() - dropStart));
                animationId = requestAnimationFrame(gameLoop);
                pauseButton.textContent = '暂停';
            }
        }
        
        // 重置游戏
        function resetGame() {
            // 取消动画帧
            cancelAnimationFrame(animationId);
            
            // 重置游戏状态
            score = 0;
            gameOver = false;
            isPaused = false;
            isStarted = false;
            dropInterval = 1000;
            
            // 更新显示
            scoreDisplay.textContent = `得分: ${score}`;
            
            // 重置游戏板
            createBoard();
            
            // 生成新方块（仅下一个方块）
            nextPiece = generatePiece();
            
            // 绘制初始状态
            draw();
            drawNextPiece();
            
            // 更新按钮状态
            startButton.textContent = '开始游戏';
            pauseButton.disabled = true;
            pauseButton.textContent = '暂停';
        }
        
        // 显示游戏结束
        function showGameOver() {
            cancelAnimationFrame(animationId);
            
            // 更新最终得分
            finalScoreDisplay.textContent = score;
            
            // 显示游戏结束弹窗
            gameOverModal.style.display = 'flex';
        }
        
        // 隐藏游戏结束弹窗
        function hideGameOver() {
            gameOverModal.style.display = 'none';
        }
        
        // 设置事件监听器
        function setEventListeners() {
            // 键盘控制
            document.addEventListener('keydown', function(e) {
                if (!isStarted || gameOver) return;
                
                switch (e.keyCode) {
                    case 37: // 左箭头
                        move(-1, 0);
                        break;
                    case 39: // 右箭头
                        move(1, 0);
                        break;
                    case 40: // 下箭头
                        move(0, 1);
                        break;
                    case 38: // 上箭头
                        rotate();
                        break;
                    case 32: // 空格键
                        hardDrop();
                        break;
                    case 80: // P键暂停
                        togglePause();
                        break;
                }
            });
            
            // 开始按钮
            startButton.addEventListener('click', startGame);
            
            // 暂停按钮
            pauseButton.addEventListener('click', togglePause);
            
            // 返回按钮
            backButton.addEventListener('click', function() {
                if (confirm('确定要返回主界面吗？当前游戏进度将丢失。')) {
                    window.location.href = 'index.html';
                }
            });
            
            // 重新开始按钮
            restartButton.addEventListener('click', function() {
                hideGameOver();
                resetGame();
                startGame();
            });
        }
        
        // 初始化游戏
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
