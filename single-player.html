<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块 - 单人游戏</title>
    <style>
        /* 全局样式 */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        /* 游戏容器样式 */
        #game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* 游戏画布区域 */
        #game-area {
            position: relative;
        }
        
        /* 游戏画布 */
        #tetris-canvas {
            background-color: rgba(0, 0, 0, 0.7);
            border: 3px solid #4e54c8;
            border-radius: 5px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        /* 信息面板 */
        #info-panel {
            background-color: rgba(0, 0, 0, 0.7);
            border: 3px solid #8f94fb;
            border-radius: 5px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        /* 分数显示 */
        #score-display {
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
            color: #4e54c8;
        }
        
        /* 下一个方块预览 */
        #next-piece-container {
            margin: 20px 0;
            text-align: center;
        }
        
        #next-piece-title {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        
        #next-piece-canvas {
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #8f94fb;
            border-radius: 5px;
            margin: 0 auto;
        }
        
        /* 游戏说明 */
        #instructions {
            margin: 20px 0;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* 按钮区域 */
        #button-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .game-control-btn {
            padding: 12px;
            font-size: 1em;
            color: white;
            background: linear-gradient(45deg, #4e54c8, #8f94fb);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .game-control-btn:hover {
            background: linear-gradient(45deg, #8f94fb, #4e54c8);
            transform: translateY(-2px);
        }
        
        .game-control-btn:active {
            transform: translateY(1px);
        }
        
        /* 游戏结束遮罩 */
        #game-over-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #final-score {
            font-size: 2em;
            margin-bottom: 20px;
            color: #ff6b6b;
        }
        
        /* 返回按钮图标 */
        .back-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
            background-color: white;
            mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z'/%3E%3C/svg%3E") no-repeat center;
        }
    </style>
</head>
<body>
    <!-- 游戏主容器 -->
    <div id="game-container" data-screen-id="1001">
        <!-- 游戏画布区域 -->
        <div id="game-area">
            <!-- 俄罗斯方块主画布 -->
            <canvas id="tetris-canvas" width="300" height="600"></canvas>
            
            <!-- 游戏结束遮罩 -->
            <div id="game-over-mask">
                <div id="final-score">最终得分: 0</div>
                <button id="restart-btn" class="game-control-btn">重新开始</button>
            </div>
        </div>
        
        <!-- 信息面板 -->
        <div id="info-panel">
            <!-- 分数显示 -->
            <div id="score-display">得分: 0</div>
            
            <!-- 下一个方块预览 -->
            <div id="next-piece-container">
                <div id="next-piece-title">下一个方块:</div>
                <canvas id="next-piece-canvas" width="120" height="120"></canvas>
            </div>
            
            <!-- 游戏说明 -->
            <div id="instructions">
                <h3>游戏说明:</h3>
                <p>← → : 左右移动</p>
                <p>↑ : 旋转方块</p>
                <p>↓ : 加速下落</p>
                <p>空格 : 直接落到底部</p>
            </div>
            
            <!-- 按钮区域 -->
            <div id="button-area">
                <button id="start-btn" class="game-control-btn">游戏开始</button>
                <button id="back-btn" class="game-control-btn">
                    <span class="back-icon"></span>返回主界面
                </button>
            </div>
        </div>
    </div>

    <script>
        // 游戏常量定义
        const COLS = 10;  // 游戏区域列数
        const ROWS = 20;  // 游戏区域行数
        const BLOCK_SIZE = 30;  // 每个方块的大小(像素)
        const NEXT_BLOCK_SIZE = 20;  // 下一个方块预览的大小
        
        // 方块形状定义
        const SHAPES = [
            [],  // 空形状(占位)
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],  // I
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],  // J
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],  // L
            [[4, 4], [4, 4]],  // O
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],  // S
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],  // T
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]   // Z
        ];
        
        // 方块颜色定义
        const COLORS = [
            '#000000',  // 0: 空
            '#00FFFF',  // 1: I (青色)
            '#0000FF',  // 2: J (蓝色)
            '#FF7F00',  // 3: L (橙色)
            '#FFFF00',  // 4: O (黄色)
            '#00FF00',  // 5: S (绿色)
            '#800080',  // 6: T (紫色)
            '#FF0000'   // 7: Z (红色)
        ];
        
        // 游戏状态变量
        let canvas, ctx;  // 主画布和上下文
        let nextCanvas, nextCtx;  // 下一个方块画布和上下文
        let board = [];  // 游戏板(记录已固定的方块)
        let currentPiece = null;  // 当前方块
        let nextPiece = null;  // 下一个方块
        let score = 0;  // 当前分数
        let gameOver = false;  // 游戏是否结束
        let gameStarted = false;  // 游戏是否开始
        let dropInterval = 1000;  // 方块下落间隔(毫秒)
        let dropStart;  // 上次下落时间
        let animationId;  // 动画ID(用于取消动画)
        
        // 初始化游戏
        function init() {
            // 获取画布和上下文
            canvas = document.getElementById('tetris-canvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('next-piece-canvas');
            nextCtx = nextCanvas.getContext('2d');
            
            // 初始化游戏板
            createBoard();
            
            // 生成第一个下一个方块
            nextPiece = generatePiece();
            
            // 设置事件监听器
            setupEventListeners();
            
            // 绘制初始状态
            draw();
            drawNextPiece();
        }
        
        // 创建游戏板
        function createBoard() {
            // 创建ROWS x COLS的二维数组，初始值为0(空)
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = 0;
                }
            }
        }
        
        // 生成随机方块
        function generatePiece() {
            // 随机选择方块类型(1-7)
            const type = Math.floor(Math.random() * 7) + 1;
            const shape = SHAPES[type];
            
            // 计算方块初始位置(居中)
            const col = Math.floor((COLS - shape[0].length) / 2);
            const row = 0;
            
            return { type, shape, row, col };
        }
        
        // 绘制游戏板
        function drawBoard() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制游戏板
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawBlock(c, r, board[r][c]);
                    }
                }
            }
            
            // 绘制网格线(可选)
            drawGrid();
        }
        
        // 绘制单个方块
        function drawBlock(col, row, type) {
            const x = col * BLOCK_SIZE;
            const y = row * BLOCK_SIZE;
            
            // 绘制方块主体
            ctx.fillStyle = COLORS[type];
            ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 绘制方块边框
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 添加高光效果
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(x + 2, y + 2, BLOCK_SIZE - 4, 4);
            ctx.fillRect(x + 2, y + 2, 4, BLOCK_SIZE - 4);
        }
        
        // 绘制网格线
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 绘制垂直线
            for (let c = 0; c <= COLS; c++) {
                ctx.beginPath();
                ctx.moveTo(c * BLOCK_SIZE, 0);
                ctx.lineTo(c * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // 绘制水平线
            for (let r = 0; r <= ROWS; r++) {
                ctx.beginPath();
                ctx.moveTo(0, r * BLOCK_SIZE);
                ctx.lineTo(COLS * BLOCK_SIZE, r * BLOCK_SIZE);
                ctx.stroke();
            }
        }
        
        // 绘制当前方块
        function drawPiece() {
            if (!currentPiece) return;
            
            const { shape, row, col } = currentPiece;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        drawBlock(col + c, row + r, shape[r][c]);
                    }
                }
            }
        }
        
        // 绘制下一个方块
        function drawNextPiece() {
            // 清除下一个方块画布
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (!nextPiece) return;
            
            const { shape } = nextPiece;
            const centerX = (nextCanvas.width - shape[0].length * NEXT_BLOCK_SIZE) / 2;
            const centerY = (nextCanvas.height - shape.length * NEXT_BLOCK_SIZE) / 2;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const x = centerX + c * NEXT_BLOCK_SIZE;
                        const y = centerY + r * NEXT_BLOCK_SIZE;
                        
                        // 绘制方块主体
                        nextCtx.fillStyle = COLORS[shape[r][c]];
                        nextCtx.fillRect(x, y, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                        
                        // 绘制方块边框
                        nextCtx.strokeStyle = '#000';
                        nextCtx.lineWidth = 1;
                        nextCtx.strokeRect(x, y, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
                    }
                }
            }
        }
        
        // 绘制所有内容
        function draw() {
            drawBoard();
            drawPiece();
        }
        
        // 游戏主循环
        function gameLoop(timestamp) {
            if (gameOver) {
                showGameOver();
                return;
            }
            
            if (!gameStarted) {
                animationId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // 控制方块下落速度
            if (!dropStart) {
                dropStart = timestamp;
            }
            
            const delta = timestamp - dropStart;
            
            if (delta > dropInterval) {
                moveDown();
                dropStart = timestamp;
            }
            
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 移动方块
        function moveDown() {
            if (!currentPiece) return;
            
            if (!collision(0, 1, currentPiece.shape)) {
                currentPiece.row++;
                return true;
            }
            
            // 如果不能移动，则固定方块
            lockPiece();
            
            // 检查是否有完整的行
            checkRows();
            
            // 生成新方块
            currentPiece = nextPiece;
            nextPiece = generatePiece();
            drawNextPiece();
            
            // 检查游戏是否结束
            if (collision(0, 0, currentPiece.shape)) {
                gameOver = true;
            }
            
            return false;
        }
        
        // 快速下落(空格键)
        function hardDrop() {
            if (!currentPiece || gameOver) return;
            
            while (moveDown()) {
                // 继续下落直到不能移动
            }
        }
        
        // 左移
        function moveLeft() {
            if (!currentPiece || gameOver) return;
            
            if (!collision(-1, 0, currentPiece.shape)) {
                currentPiece.col--;
                draw();
            }
        }
        
        // 右移
        function moveRight() {
            if (!currentPiece || gameOver) return;
            
            if (!collision(1, 0, currentPiece.shape)) {
                currentPiece.col++;
                draw();
            }
        }
        
        // 旋转
        function rotate() {
            if (!currentPiece || gameOver) return;
            
            const newShape = rotateMatrix(currentPiece.shape);
            
            if (!collision(0, 0, newShape)) {
                currentPiece.shape = newShape;
                draw();
            }
        }
        
        // 旋转矩阵(顺时针90度)
        function rotateMatrix(matrix) {
            const N = matrix.length;
            const rotated = [];
            
            for (let i = 0; i < N; i++) {
                rotated[i] = [];
                for (let j = 0; j < N; j++) {
                    rotated[i][j] = matrix[N - j - 1][i];
                }
            }
            
            return rotated;
        }
        
        // 碰撞检测
        function collision(offsetX, offsetY, pieceShape) {
            const { row, col } = currentPiece;
            
            for (let r = 0; r < pieceShape.length; r++) {
                for (let c = 0; c < pieceShape[r].length; c++) {
                    if (!pieceShape[r][c]) continue;
                    
                    const newX = col + c + offsetX;
                    const newY = row + r + offsetY;
                    
                    // 检查边界
                    if (newX < 0 || newX >= COLS || newY >= ROWS) {
                        return true;
                    }
                    
                    // 检查是否与其他方块重叠
                    if (newY >= 0 && board[newY][newX]) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 固定方块到游戏板
        function lockPiece() {
            const { shape, row, col } = currentPiece;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const boardRow = row + r;
                        const boardCol = col + c;
                        
                        if (boardRow >= 0) {
                            board[boardRow][boardCol] = shape[r][c];
                        }
                    }
                }
            }
        }
        
        // 检查是否有完整的行
        function checkRows() {
            let linesCleared = 0;
            
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    // 移除该行
                    board.splice(r, 1);
                    // 在顶部添加新行
                    board.unshift(Array(COLS).fill(0));
                    // 因为删除了行，需要再次检查同一行(现在是新行)
                    r++;
                    linesCleared++;
                }
            }
            
            if (linesCleared > 0) {
                // 更新分数
                updateScore(linesCleared);
                // 根据分数调整下落速度
                adjustSpeed();
            }
        }
        
        // 更新分数
        function updateScore(lines) {
            // 根据消除的行数计算得分
            const points = [0, 40, 100, 300, 1200][lines];
            score += points;
            
            // 更新分数显示
            document.getElementById('score-display').textContent = `得分: ${score}`;
        }
        
        // 根据分数调整下落速度
        function adjustSpeed() {
            // 每1000分加快速度
            const level = Math.floor(score / 1000);
            // 速度上限为100ms
            dropInterval = Math.max(100, 1000 - level * 100);
        }
        
        // 显示游戏结束
        function showGameOver() {
            document.getElementById('final-score').textContent = `最终得分: ${score}`;
            document.getElementById('game-over-mask').style.display = 'flex';
        }
        
        // 重置游戏
        function resetGame() {
            // 取消动画
            cancelAnimationFrame(animationId);
            
            // 重置游戏状态
            board = [];
            currentPiece = null;
            nextPiece = null;
            score = 0;
            gameOver = false;
            gameStarted = false;
            dropInterval = 1000;
            dropStart = null;
            
            // 更新UI
            document.getElementById('score-display').textContent = '得分: 0';
            document.getElementById('game-over-mask').style.display = 'none';
            document.getElementById('start-btn').textContent = '游戏开始';
            
            // 重新初始化
            createBoard();
            nextPiece = generatePiece();
            draw();
            drawNextPiece();
        }
        
        // 开始游戏
        function startGame() {
            if (gameStarted) return;
            
            gameStarted = true;
            gameOver = false;
            document.getElementById('start-btn').textContent = '游戏中...';
            
            // 生成第一个方块
            currentPiece = nextPiece;
            nextPiece = generatePiece();
            drawNextPiece();
            
            // 开始游戏循环
            dropStart = null;
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 键盘控制
            document.addEventListener('keydown', function(e) {
                if (!gameStarted || gameOver) return;
                
                switch (e.keyCode) {
                    case 37: // 左箭头
                        moveLeft();
                        break;
                    case 39: // 右箭头
                        moveRight();
                        break;
                    case 40: // 下箭头
                        moveDown();
                        break;
                    case 38: // 上箭头
                        rotate();
                        break;
                    case 32: // 空格
                        hardDrop();
                        break;
                }
            });
            
            // 开始按钮
            document.getElementById('start-btn').addEventListener('click', function() {
                if (!gameStarted) {
                    startGame();
                }
            });
            
            // 重新开始按钮
            document.getElementById('restart-btn').addEventListener('click', resetGame);
            
            // 返回按钮
            document.getElementById('back-btn').addEventListener('click', function() {
                window.location.href = 'index.html';
            });
        }
        
        // 初始化游戏
        window.addEventListener('load', init);
    </script>
</body>
</html>
